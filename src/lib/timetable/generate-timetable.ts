
'use server';

/**
 * @fileOverview Generates an optimized timetable using an intelligent algorithm based on imported data and defined constraints.
 *
 * - generateTimetable - A function that generates an optimized timetable and an analysis report in a single call.
 * - GenerateTimetableInput - The input type for the generateTimetable function.
 * - GenerateTimetableOutput - The return type for the generateTimetable function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';
import { GenerateTimetableOutputSchema, GenerateTimetableInputSchema } from '@/lib/timetable/schemas';


export type GenerateTimetableInput = z.infer<typeof GenerateTimetableInputSchema>;
export type GenerateTimetableOutput = z.infer<typeof GenerateTimetableOutputSchema>;

const generationPrompt = ai.definePrompt({
  name: 'timetableGenerationPrompt',
  model: 'googleai/gemini-1.5-flash',
  input: { schema: GenerateTimetableInputSchema },
  output: { schema: GenerateTimetableOutputSchema },
  prompt: `You are an intelligent timetable generator for a university/college dashboard. The user will choose a Course (e.g., BTech, B.Ed., M.Tech), then — depending on the course — optionally choose a Branch (for BTech this could be CSE, ECE, ME, etc.). For each branch the user can choose one or more Batches (CSE1, CSE2, ... or BEAD1, BEAD2, etc.). The timetable must be generated by batch/class, not by listing subjects first. Your job is to produce a weekly timetable for the selected batch(es) that assigns classes to time slots, respecting constraints and preferences provided by the user.

You will be given the following data as JSON strings:
- Student Data: {{studentData}}
- Faculty Data: {{facultyData}}
- ALL Course Data: {{courseData}}
- Room Data: {{roomData}}
- Scheduling Constraints: {{constraints}}
- Programs to Schedule For (optional): {{{programs}}}
- Days to Schedule For (optional): {{{days}}}
- Existing Timetable (optional, for modification): {{{existingTimetable}}}
- Selected Class for Specific Generation (optional): {{{selectedClass}}}
- Specific Generation Mode (optional): {{{specificGeneration}}}

**IMPORTANT: CLASS-SPECIFIC GENERATION**
If specificGeneration is true and selectedClass is provided:
- Focus ONLY on creating a timetable for that specific class/section
- Use the course and class information to create a targeted schedule
- Include classId, className, and program fields in each timetable entry
- The generated timetable should be titled in the format: "[Course Code] – [Class Name] Timetable"
- Ensure subjects, teachers, rooms, and periods are assigned uniquely for this class
- Do NOT generate schedules for other classes unless specifically requested

**CRITICAL: The timetable must be structured as a grid with:**
- Rows: Time slots based on the provided slot_duration_minutes
- Columns: Days of the week as specified in academic_days
- Each cell contains course information for that specific day and time slot

**IMPORTANT: Day Selection Logic:**
- If the 'days' array contains specific days (e.g., ["Monday"]), ONLY generate timetable entries for those specific days
- If the 'days' array is empty or contains all days from academic_days, generate for all days
- DO NOT generate entries for days not specified in the 'days' array

**Your Task is a two-step process:**

**Step 1: Generate the Timetable**
Adhere to these rules with absolute precision:
1.  **Filter Courses by Program**: If a \`programs\` array is provided (e.g., ["B.Ed.", "FYUP"]), you MUST first filter the \`courseData\` to get ONLY the courses associated with those programs. You will then generate a schedule for THIS SUBSET of courses. If \`programs\` is empty or not provided, you will schedule ALL courses from \`courseData\`.
2.  **Modify, Don't Erase:** If an \`existingTimetable\` is provided, you must treat it as the source of truth. Your job is to ADD the new courses (from your filtered program list) to this existing schedule. DO NOT remove or alter existing entries unless it's absolutely necessary to resolve a high-priority conflict for a course you are newly adding.
3.  **No Double Bookings (Highest Priority):** A faculty member, a student group (based on their enrolled courses), or a room cannot be in two places at once.
4.  **Constraint Adherence:** Strictly enforce faculty availability, room capacity, course requirements (e.g., labs), and any program-specific time blocks (like internships or teaching practice).
5.  **Create a Dense Schedule (CRITICAL - NO EMPTY SLOTS):** Your goal is to create a highly utilized and efficient schedule. Fill EVERY SINGLE slot for the requested courses and days. An empty timetable is a failure unless no courses were requested. EVERY time slot must have an entry - ABSOLUTELY NO SLOTS can be left empty with "—" or blank or "Free Period". If you run out of unique courses, repeat courses with different faculty or rooms to ensure COMPLETE 100% COVERAGE. ZERO tolerance for empty slots!
6.  **COURSE DIVERSITY (CRITICAL):** You MUST use DIFFERENT courses across the timetable. Do NOT schedule the same course repeatedly. Rotate through available courses to create variety.
7.  **Conflict Logging:** If a conflict is unavoidable when adding a new class, schedule one class and log the other in the \`conflicts\` array. Do not simply leave a slot empty if a conflict is the reason.
8.  **Day-Specific Scheduling (CRITICAL):** If a 'days' array is provided, ONLY create timetable entries for those specific days. For example, if days=["Monday", "Wednesday", "Friday"], you must generate complete schedules for Monday, Wednesday, and Friday - not just Monday. Each specified day needs full time slot coverage. DO NOT concentrate all entries on just one day.

**Step 2: Generate the Analysis Report**
After generating the timetable, immediately write a detailed analysis report in the \`report\` field of the JSON output. This report MUST include:
1.  **Summary of Changes:** If you modified an existing timetable, briefly state what you added (e.g., "Successfully scheduled 12 courses for the B.Ed. and ITEP programs on Monday and Wednesday.").
2.  **Constraint Adherence Verification:** Explicitly confirm how you followed key constraints for the NEWLY ADDED classes.
3.  **Faculty Workload Analysis:** Provide a quantitative breakdown of hours assigned to several key faculty members vs. their expected workload.
4.  **Resource Utilization Analysis:** Calculate and state the overall room utilization percentage and identify peak/off-peak hours.
5.  **Actionable Recommendations:** Provide specific suggestions for improvement.

**Fallback Protocol:**
If you cannot schedule any of the requested courses due to a fundamental contradiction, return the \`existingTimetable\` unmodified (if provided), leave the \`timetable\` array otherwise empty, and use the \`report\` field to explain the exact reason for the failure. **Do not error out.**

**Final Output:**
The timetable array must contain entries with this exact structure:
- Each entry must have: day (from academic_days), time (matching the time slots based on slot_duration_minutes), course, courseCode, faculty, room
- If generating for a specific class, also include: classId, className, program
- Generate entries ONLY for the days specified in the 'days' array
- Generate entries for ALL time slots for each selected day - NO EMPTY SLOTS ALLOWED
- Declared breaks should be respected and no classes scheduled during them
- If only specific days are selected (e.g., ["Monday"]), only generate entries for those days
- If generating for a specific class (specificGeneration=true), create a focused timetable with the course and class information in the header format: "[Course Code] – [Class Name] Timetable"
- Your response MUST be a single, valid JSON object containing \`timetable\`, \`conflicts\`, and \`report\` keys.

**IMPORTANT: CLASS-SPECIFIC GENERATION**
If specificGeneration is true and selectedClass is provided:
- Focus ONLY on creating a timetable for that specific class/section
- Use the course and class information to create a targeted schedule
- Include classId, className, and program fields in each timetable entry
- The generated timetable should be titled in the format: "[Course Code] – [Class Name] Timetable"
- Ensure subjects, teachers, rooms, and periods are assigned uniquely for this class
- Do NOT generate schedules for other classes unless specifically requested

**CRITICAL: The timetable must be structured as a grid with:**
- Rows: Time slots based on the provided slot_duration_minutes
- Columns: Days of the week as specified in academic_days
- Each cell contains course information for that specific day and time slot

**IMPORTANT: Day Selection Logic:**
- If the 'days' array contains specific days (e.g., ["Monday"]), ONLY generate timetable entries for those specific days
- If the 'days' array is empty or contains all days from academic_days, generate for all days
- DO NOT generate entries for days not specified in the 'days' array

**Your Task is a two-step process:**

**Step 1: Generate the Timetable**
Adhere to these rules with absolute precision:
1.  **Filter Courses by Program**: If a \`programs\` array is provided (e.g., ["B.Ed.", "FYUP"]), you MUST first filter the \`courseData\` to get ONLY the courses associated with those programs. You will then generate a schedule for THIS SUBSET of courses. If \`programs\` is empty or not provided, you will schedule ALL courses from \`courseData\`.
2.  **Modify, Don't Erase:** If an \`existingTimetable\` is provided, you must treat it as the source of truth. Your job is to ADD the new courses (from your filtered program list) to this existing schedule. DO NOT remove or alter existing entries unless it's absolutely necessary to resolve a high-priority conflict for a course you are newly adding.
3.  **No Double Bookings (Highest Priority):** A faculty member, a student group (based on their enrolled courses), or a room cannot be in two places at once.
4.  **Constraint Adherence:** Strictly enforce faculty availability, room capacity, course requirements (e.g., labs), and any program-specific time blocks (like internships or teaching practice).
5.  **Create a Dense Schedule (CRITICAL - NO EMPTY SLOTS):** Your goal is to create a highly utilized and efficient schedule. Fill EVERY SINGLE slot for the requested courses and days. An empty timetable is a failure unless no courses were requested. EVERY time slot must have an entry - ABSOLUTELY NO SLOTS can be left empty with "—" or blank or "Free Period". If you run out of unique courses, repeat courses with different faculty or rooms to ensure COMPLETE 100% COVERAGE. ZERO tolerance for empty slots!
6.  **COURSE DIVERSITY (CRITICAL):** You MUST use DIFFERENT courses across the timetable. Do NOT schedule the same course repeatedly. Rotate through available courses to create variety.
7.  **Conflict Logging:** If a conflict is unavoidable when adding a new class, schedule one class and log the other in the \`conflicts\` array. Do not simply leave a slot empty if a conflict is the reason.
8.  **Day-Specific Scheduling (CRITICAL):** If a 'days' array is provided, ONLY create timetable entries for those specific days. For example, if days=["Monday", "Wednesday", "Friday"], you must generate complete schedules for Monday, Wednesday, and Friday - not just Monday. Each specified day needs full time slot coverage. DO NOT concentrate all entries on just one day.

**Step 2: Generate the Analysis Report**
After generating the timetable, immediately write a detailed analysis report in the \`report\` field of the JSON output. This report MUST include:
1.  **Summary of Changes:** If you modified an existing timetable, briefly state what you added (e.g., "Successfully scheduled 12 courses for the B.Ed. and ITEP programs on Monday and Wednesday.").
2.  **Constraint Adherence Verification:** Explicitly confirm how you followed key constraints for the NEWLY ADDED classes.
3.  **Faculty Workload Analysis:** Provide a quantitative breakdown of hours assigned to several key faculty members vs. their expected workload.
4.  **Resource Utilization Analysis:** Calculate and state the overall room utilization percentage and identify peak/off-peak hours.
5.  **Actionable Recommendations:** Provide specific suggestions for improvement.

**Fallback Protocol:**
If you cannot schedule any of the requested courses due to a fundamental contradiction, return the \`existingTimetable\` unmodified (if provided), leave the \`timetable\` array otherwise empty, and use the \`report\` field to explain the exact reason for the failure. **Do not error out.**

**Final Output:**
The timetable array must contain entries with this exact structure:
- Each entry must have: day (from academic_days), time (matching the time slots based on slot_duration_minutes), course, courseCode, faculty, room
- If generating for a specific class, also include: classId, className, program
- Generate entries ONLY for the days specified in the 'days' array
- Generate entries for ALL time slots for each selected day - NO EMPTY SLOTS ALLOWED
- Declared breaks should be respected and no classes scheduled during them
- If only specific days are selected (e.g., ["Monday"]), only generate entries for those days
- If generating for a specific class (specificGeneration=true), create a focused timetable with the course and class information in the header format: "[Course Code] – [Class Name] Timetable"
- Your response MUST be a single, valid JSON object containing \`timetable\`, \`conflicts\`, and \`report\` keys.
`,
});


export const generateTimetableFlow = ai.defineFlow(
  {
    name: 'generateTimetableFlow',
    inputSchema: GenerateTimetableInputSchema,
    outputSchema: GenerateTimetableOutputSchema,
  },
  async (input) => {
    const constraintsObject = JSON.parse(input.constraints);
    
    // Inject the current date into the constraints object to allow the AI to handle date-range constraints.
    constraintsObject.currentDate = new Date().toISOString();

    const updatedInput = {
      ...input,
      constraints: JSON.stringify(constraintsObject, null, 2), // Pretty-print for AI readability
    };
    
    const { output } = await generationPrompt(updatedInput);
    
    if (!output) {
        throw new Error("AI model returned no output.");
    }
    
    // Ensure the output conforms to the schema, even if the model messes up.
    // This provides a resilient structure that the frontend can always handle.
    return {
        timetable: output.timetable || [],
        conflicts: output.conflicts || [],
        report: output.report || "The AI model failed to generate a report, but the timetable (if any) is provided.",
    };
  }
);


export async function generateTimetable(input: GenerateTimetableInput): Promise<GenerateTimetableOutput> {
  try {
    console.log("Starting timetable generation with input:", {
      studentDataLength: input.studentData?.length || 0,
      facultyDataLength: input.facultyData?.length || 0,
      courseDataLength: input.courseData?.length || 0,
      roomDataLength: input.roomData?.length || 0,
      constraintsLength: input.constraints?.length || 0,
      programs: input.programs,
      days: input.days,
      specificGeneration: input.specificGeneration,
      selectedClass: input.selectedClass ? JSON.parse(input.selectedClass) : null
    });
    
    const result = await generateTimetableFlow(input);
    console.log("Timetable generation completed successfully");
    return result;
  } catch (error) {
    console.error("Detailed error in generateTimetable:", error);
    
    // Provide more specific error messages
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('AI API key is invalid or missing. Please check your environment configuration.');
      } else if (error.message.includes('quota')) {
        throw new Error('AI API quota exceeded. Please try again later.');
      } else if (error.message.includes('network')) {
        throw new Error('Network error occurred while calling AI service. Please check your internet connection.');
      } else {
        throw new Error(`Timetable generation failed: ${error.message}`);
      }
    } else {
      throw new Error(`Timetable generation failed: Unknown error occurred`);
    }
  }
}
